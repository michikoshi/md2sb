"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compiler = compiler;
const addListItemCount_1 = __importDefault(require("./addListItemCount"));
const generateCodeBlock_1 = __importDefault(require("./generateCodeBlock"));
class Compiler {
    constructor() {
        this.lastElmEndLine = 1;
        this.decorate = [];
    }
    isDecorateElement(node) {
        return ["emphasis", "delete", "strong", "heading"].includes(typeof node === "string" ? node : node.type);
    }
    compile(ast, _context = {
        parents: undefined,
    }) {
        let result = [...(ast.children || ast)]
            .map((node) => {
            var _a;
            return this.node2SbText(node, {
                ..._context,
                parents: ((_a = _context.parents) !== null && _a !== void 0 ? _a : []).slice(0),
            });
        })
            .join("");
        if (ast.type &&
            ast.type === "root" &&
            result.charAt(result.length - 1) !== "\n") {
            result += "\n";
        }
        return result;
    }
    node2SbText(node, context) {
        var _a;
        let result = "";
        if (context.parents.length === 0 && node.type !== "heading") {
            result += "\n".repeat(node.position.start.line - this.lastElmEndLine);
            this.lastElmEndLine = node.position.end.line;
        }
        else if (node.type === "listItem") {
            const lineBreak = Math.max(node.position.start.line - this.lastElmEndLine - 1, 0);
            result += "\n".repeat(lineBreak);
            this.lastElmEndLine = node.position.end.line;
        }
        context.parents.push(node.type);
        switch (node.type) {
            case "thematicBreak":
                result += "[/icons/hr.icon]";
                break;
            case "emphasis":
                this.decorate.push("/");
                result += this.compile(node.children, context);
                break;
            case "delete":
                this.decorate.push("-");
                result += this.compile(node.children, context);
                break;
            case "strong":
                this.decorate.push("*");
                result += this.compile(node.children, context);
                break;
            case "heading":
                if (!("depth" in node))
                    break;
                this.decorate.push("*".repeat(Math.max(1, 5 - node.depth)));
                result += this.compile(node.children, context);
                break;
            case "link":
                if (!("url" in node))
                    break;
                if (node.children.filter((_) => _.type === "image").length) {
                    result += node.children
                        .map((n) => {
                        if (n.type === "image" && "url" in n)
                            return `[${n.url} ${node.url}]`;
                        return `[${this.compile(n, context)} ${node.url}]`;
                    })
                        .join("");
                }
                else {
                    result += `[${this.compile(node.children, context)} ${node.url}]`;
                }
                break;
            case "image":
                if ("url" in node)
                    result += `[${node.url}]`;
                break;
            case "inlineCode":
                if ("value" in node)
                    result += `\`${node.value}\``;
                break;
            case "blockquote":
                {
                    const depth = context.parents.filter((p) => p === "blockquote").length;
                    const quoteMark = "> ".repeat(Math.max(depth - 1, 1));
                    result +=
                        (depth === 1 ? "" : "\n") +
                            quoteMark +
                            this.compile(node.children, context)
                                .split(/\n/)
                                .join("\n" + quoteMark);
                }
                break;
            case "code":
                result += (0, generateCodeBlock_1.default)(node);
                break;
            case "table":
                result += "table:table\n";
                result +=
                    " " +
                        node.children
                            .map((tableRow) => tableRow.children
                            .map((tableCell) => {
                            context.parents.push("tableCell");
                            return this.compile(tableCell.children, context);
                        })
                            .join("\t"))
                            .join("\n ");
                break;
            case "list":
                {
                    const tagName = "ordered" in node && node.ordered ? "ol" : "ul";
                    context.listItemCount = 0;
                    context.parents[context.parents.length - 1] = tagName;
                    result += this.compile(tagName === "ol" ? (0, addListItemCount_1.default)(node.children) : node.children, context);
                }
                break;
            case "listItem": {
                const depth = context.parents.filter((i) => i === "ol" || i === "ul").length;
                const isChangedDepth = 2 <= depth && ((_a = context.listDepth) !== null && _a !== void 0 ? _a : 0) < depth;
                const inner = this.compile(node.children, {
                    ...context,
                    listDepth: depth,
                });
                result +=
                    (isChangedDepth ? "\n" : "") +
                        " ".repeat(depth) +
                        ("listItemCount" in node && node.listItemCount
                            ? node.listItemCount + ". "
                            : "") +
                        inner +
                        (isChangedDepth ? "" : "\n");
                break;
            }
            case "paragraph":
                result += this.compile(node.children, context);
                break;
            case "text":
                {
                    if (!("value" in node))
                        break;
                    let textValue = node.value;
                    if (context.parents.includes("tableCell"))
                        textValue = node.value.replace(/(\s|\t)+$/, "");
                    if (context.parents.includes("listItem"))
                        textValue = node.value;
                    result += textValue;
                }
                break;
        }
        if (this.isDecorateElement(node) &&
            !context.parents.slice(0, -1).filter((_) => this.isDecorateElement(_))
                .length) {
            result = `[${this.decorate.join("")} ${result}]`;
            if (node.type === "heading") {
                result =
                    "\n".repeat(Math.max(node.position.start.line - this.lastElmEndLine, 0)) + result;
                this.lastElmEndLine = node.position.end.line;
            }
            this.decorate = [];
        }
        return result;
    }
}
function compiler() {
    const compile = new Compiler();
    this.Compiler = compile.compile.bind(compile);
}
//# sourceMappingURL=compiler.js.map